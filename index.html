<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convert PDF to Scanned PDF Locally Without Uploading to Server</title>
    <meta
      name="keywords"
      content="pdf to scanned pdf,pdf to scanned pdf online,convert pdf to scanned pdf online"
    />
    <meta name="description" content="Convert any PDF with selectable text, images or pasted signatures to a non-selectable scanned document without uploading your files to a server. All processing to make PDF look scanned happens instantly and locally in your browser.">
    <meta name="robots" content="index, follow, max-image-preview:large">
    <link rel="canonical" href="https://pdftoscan.online/">
    <meta
      property="og:image"
      content="https://pdftoscan.online/favicon.svg"
    />
    <meta property="og:title" content="Convert PDF to Scanned PDF Locally Without Uploading to Server">
    <meta
      property="og:description"
      content="Convert any PDF with selectable text, images or pasted signatures to a non-selectable scanned document without uploading your files to a server. All processing to make PDF look scanned happens instantly and locally in your browser."
    />

    <meta property="og:type" content="website">
    <meta
      property="og:url"
      content="https://pdftoscan.online"
    />
    <meta  property="og:site_name" content="pdftoscan" />
    <meta
      
      property="twitter:domain"
      content="https://pdftoscan.online"
    />
    <meta
      
      property="twitter:url"
      content="https://pdftoscan.online"
    />
    <meta
      
      name="twitter:title"
      content=" Convert PDF to Scanned PDF Locally Without Uploading to Server "
    />
    <meta
      
      name="twitter:description"
      content=" Convert any PDF with selectable text, images or pasted signatures to a non-selectable scanned document without uploading your files to a server. All processing to make PDF look scanned happens instantly and locally in your browser."
    />
    <meta
      
      name="twitter:image:src"
      content="https://pdftoscan.online/favicon.svg"
    />
    <link rel="manifest" href="/manifest.json" />
    
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" defer></script>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "url": "https://pdftoscan.online",
        "logo": "https://pdftoscan.online/favicon.svg"
      }
    </script>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "name": "pdftoscan",
        "alternateName": "pdftoscan",
        "url": "https://pdftoscan.online"
      }
    </script>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "WebApplication",
        "operatingSystem":"All - Windows/Mac/iOS/Linux/Android",
        "applicationCategory":"UtilitiesApplication",
        "name": "PDF to Scanned PDF",
        "url":"https://pdftoscan.online",
        "image":"https://pdftoscan.online/favicon.png",
        "offers": {
          "@type": "Offer",
          "price": "0.00",
          "priceCurrency": "USD"
        },
  "description": "A secure, browser-based tool to rasterize PDF without uploading files to a server."
}
      }
    </script>
    <script>
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("/serviceworker.js")
            .then((reg) => console.log("Success: ", reg.scope))
            .catch((err) => console.log("Failure: ", err));
        });
      }
    </script>
   <style>
    :root {
        --h-bg: #f5f5f7;
        --h-text: #000000;      /* Stark Black */
        --h-subtext: #666666;   /* Muted Grey */
        --h-accent: #0071e3;    /* Primary Action Color */
        --h-border: #d2d2d7;    /* Light Borders */
        --h-surface: #ffffff;   /* White Surface */
        --h-laser: #000000;     /* Laser becomes black for this minimal theme */
        --h-font: -apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", Roboto, sans-serif;
    }
    body { 
        font-family: var(--h-font);
        transition: background 0.3s ease, color 0.3s ease; 
        -webkit-font-smoothing: antialiased;
        background-color: var(--h-bg);
    }     
    .human-view {
        flex-direction: column; 
        align-items: flex-start; /* Left Align Everything */
        justify-content: flex-start;
        padding: 60px 20px; 
        max-width: 1000px; 
        margin: 0 auto;
        position: relative;
    }

    .app-header { 
        margin-bottom: 4rem; 
        text-align: left; /* Left Align Header */
        width: 100%;
        position: relative;
        padding-top: 2rem;
    }

    .app-header h1 { 
        font-size: 3.5rem; /* Large Hero Text */
        font-weight: 700; 
        letter-spacing: -0.04em; 
        line-height: 1.1;
        margin-bottom: 1rem;
        color: var(--h-text);
        max-width: 800px;
    }
    
    .app-header p { 
        color: var(--h-subtext); 
        font-size: 1.2rem;
        font-weight: 400;
        max-width: 600px;
    }
    
    /* Dropzone - Minimalist Input Style */
    .dropzone {
        width: 100%; 
        background: var(--h-surface); 
        border: 1px solid var(--h-border); /* Subtle thin border */
        border-radius: 8px; /* Slight rounding */
        padding: 4rem 2rem; 
        text-align: center; 
        cursor: pointer;
        transition: all 0.2s ease; 
        position: relative; 
        overflow: hidden;
        min-height: 200px; 
        display: flex; 
        flex-direction: column; 
        justify-content: center; 
        align-items: center;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.02);
    }
    .dropzone:hover { 
        border-color: #a3a3a3; 
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.05); 
    }

    /* Laser - Made Subtle/Black */
    .scan-beam {
        position: absolute; top: 0; left: 0; width: 100%; height: 2px;
        background: var(--h-text); box-shadow: 0 0 10px rgba(0,0,0,0.2);
        opacity: 0; z-index: 10; pointer-events: none;
    }
    .dropzone.scanning { border-color: var(--h-text); background: #fafafa; cursor: wait; }
    .dropzone.scanning .scan-beam {
        opacity: 1; 
        animation: scanner 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
        will-change: top;
    }
    @keyframes scanner { 
        0% { top: 0%; opacity: 0; } 10% { opacity: 1; } 90% { opacity: 1; } 100% { top: 100%; opacity: 0; } 
    }

    .file-stack { margin-top: 1.5rem; width: 100%; text-align: left; }
    .file-item { 
        display: flex; justify-content: space-between; padding: 1rem 0; 
        border-bottom: 1px solid var(--h-border); font-size: 0.9rem; animation: fadeIn 0.3s ease;
        color: var(--h-subtext);
    }
    #processor-canvas { display: none; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
</style>
</head>

<body>

    <main class="human-view">
        <header class="app-header">
            <h1>Make PDF Text Un-Copyable</h1>
            <p>Convert editable documents into secure, read-only images.</p>
        </header>

        <div class="dropzone" id="dropzone" tabindex="0">
            <div class="scan-beam"></div>
            <svg width="48" height="48" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                <path d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
            </svg>
            <p style="margin-top:1rem; font-weight: 500;">Drop PDFs here</p>
            <p style="font-size: 0.85rem; color: #9ca3af;">Optimized for Speed</p>
            <p id="progress-text" style="margin-top:1rem; font-weight:500;"></p>
        </div>

        <div class="file-stack" id="file-list"></div>
    </main>
    
    <input type="file" id="file-input" multiple accept="application/pdf" style="display: none;">
    <canvas id="processor-canvas"></canvas>

    <script>
        const State = { files: [], isProcessing: false };
        const DOM = {
            body: document.body, 
            dropzone: document.getElementById('dropzone'), input: document.getElementById('file-input'),
            list: document.getElementById('file-list'), 
            canvas: document.getElementById('processor-canvas'),progressText: document.getElementById('progress-text'),
            ctx: document.getElementById('processor-canvas').getContext('2d', { alpha: false })
        };

        // FILE HANDLING
        function renderFileList() {
            DOM.list.innerHTML = '';
            State.files.forEach(f => {
                const el = document.createElement('div'); el.className = 'file-item';
                el.innerHTML = `<span>${f.name}</span> <span style="font-family:monospace; color:#6b7280;">${(f.size/1024/1024).toFixed(1)}MB</span>`;
                DOM.list.appendChild(el);
            });
        }
      async function handleFiles(list) {
            const newFiles = [];
          for (let i = 0; i < list.length; i++) {
        if (list[i].type === 'application/pdf') {
            newFiles.push(list[i]);
        }
    }
            if (newFiles.length === 0) return;

            State.files = [...State.files, ...newFiles];
            renderFileList();
            
            await startProcessing();
        }
        DOM.dropzone.onclick = () => { if(!State.isProcessing) DOM.input.click(); };
        DOM.input.onchange = (e) => handleFiles(e.target.files);
        DOM.dropzone.ondragover = (e) => { e.preventDefault(); DOM.dropzone.classList.add('active'); };
        DOM.dropzone.ondragleave = (e) => { e.preventDefault(); DOM.dropzone.classList.remove('active'); };
        DOM.dropzone.ondrop = (e) => { e.preventDefault(); DOM.dropzone.classList.remove('active'); handleFiles(e.dataTransfer.files); };
      // NEW: PASTE SUPPORT
        window.addEventListener('paste', e => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            const pdfs = [];
            for (let i = 0; i < items.length; i++) {
                if (items[i].kind === 'file' && items[i].type === 'application/pdf') {
                    pdfs.push(items[i].getAsFile());
                }
            }
            if (pdfs.length > 0) {
                e.preventDefault(); // Stop default paste (unlikely to matter here but good practice)
                DOM.dropzone.classList.add('active'); // Quick visual flash
                setTimeout(() => DOM.dropzone.classList.remove('active'), 200);
                handleFiles(pdfs);
            }
        });
       async function waitForLibraries() {
    if (window.pdfjsLib && window.jspdf) return;

    return new Promise(resolve => {
        function check() {
            if (window.pdfjsLib && window.jspdf) {
                resolve(); 
            } else {
                requestAnimationFrame(check); 
            }
        }
        check(); 
    });
}

async function startProcessing() {
    if (State.isProcessing || State.files.length === 0) return;
    State.isProcessing = true;
    DOM.dropzone.classList.add('scanning');

    await waitForLibraries();
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    const { jsPDF } = window.jspdf;

    const maxWorkers = navigator.hardwareConcurrency || 4;

    const createProgressUpdater = () => {
        let lastUpdate = 0;
        return text => {
            const now = Date.now();
            if (now - lastUpdate > 100) {
                DOM.progressText.innerText = text;
                lastUpdate = now;
            }
        };
    };

    // Process PDFs sequentially to save memory
    for (const file of State.files) {
        await processSinglePDF(file, jsPDF, maxWorkers, createProgressUpdater());
    }

    // Clean up
    State.files = [];
    renderFileList();
    DOM.dropzone.classList.remove('scanning');
    State.isProcessing = false;
}
    async function processSinglePDF(file, jsPDF, maxWorkers, createProgress) {
    const arrayBuffer = await file.arrayBuffer();
    const pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
    const totalPages = pdfDoc.numPages;
    const originalName = file.name.replace(/\.pdf$/i, '');
    const pageQueue = Array.from({ length: totalPages }, (_, i) => i + 1);

    const outputPDF = new jsPDF({ unit: 'px', hotfixes: ["px_scaling"] });

    let nextPageToAdd = 1; // Track page order
    const pageBuffer = {};  // Hold pages that finish out-of-order

    function createWorker() {
        const worker = new Worker('pdf-worker.js');
        worker.onmessage = e => {
            const { dataURL, pageIndex } = e.data;
            pageBuffer[pageIndex] = dataURL;

            // Try adding pages in order
            while (pageBuffer[nextPageToAdd]) {
                const dataURLToAdd = pageBuffer[nextPageToAdd];
                delete pageBuffer[nextPageToAdd];

                const img = new Image();
                img.src = dataURLToAdd;
                img.onload = () => {
                    const pdfW = img.width;
                    const pdfH = img.height;

                    if (nextPageToAdd === 1) outputPDF.internal.deletePage(1); // Remove default page
                    outputPDF.addPage([pdfW, pdfH], pdfW > pdfH ? 'l' : 'p');
                    outputPDF.addImage(dataURLToAdd, 'JPEG', 0, 0, pdfW, pdfH);

                    if (nextPageToAdd === totalPages) {
                        outputPDF.save(originalName + '_scanned.pdf');
                        createProgress(`Finished ${originalName}`);
                    }
                    nextPageToAdd++;
                };
            }

            createProgress(`Processing ${originalName}: page ${pageIndex}/${totalPages}`);

            if (pageQueue.length > 0) {
                const nextPage = pageQueue.shift();
                worker.postMessage({ arrayBuffer, pageIndex: nextPage });
            } else {
                worker.terminate();
            }
        };
        return worker;
    }

    // Start workers
    const workers = [];
    for (let i = 0; i < Math.min(maxWorkers, totalPages); i++) {
        const w = createWorker();
        workers.push(w);
        const page = pageQueue.shift();
        w.postMessage({ arrayBuffer, pageIndex: page });
    }

    return new Promise(resolve => {
        const interval = setInterval(() => {
            if (nextPageToAdd > totalPages) {
                clearInterval(interval);
                resolve();
            }
        }, 100);
    });
}
</script>
</body>
</html>
