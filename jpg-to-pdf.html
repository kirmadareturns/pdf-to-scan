<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Batch JPG to PDF | Zip or Merge</title>
    <meta name="description" content="Convert JPGs to PDFs. Download as a merged document OR as a ZIP containing individual PDFs. Private, Offline, Free.">
    <meta name="theme-color" content="#2563eb">

    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --secondary: #475569;
            --bg: #f8fafc;
            --surface: #ffffff;
            --text: #0f172a;
            --text-light: #64748b;
            --border: #e2e8f0;
            --radius: 12px;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        
        body { background-color: var(--bg); color: var(--text); line-height: 1.6; min-height: 100vh; display: flex; flex-direction: column; }

        header { background: var(--surface); border-bottom: 1px solid var(--border); padding: 1rem; text-align: center; position: sticky; top: 0; z-index: 20; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        h1 { font-size: 1.5rem; font-weight: 800; color: var(--primary); letter-spacing: -0.025em; }

        main { flex: 1; max-width: 900px; width: 100%; margin: 0 auto; padding: 2rem 1rem; display: flex; flex-direction: column; align-items: center; gap: 2rem; }

        /* Drop Zone */
        .drop-zone { background: var(--surface); border: 2px dashed var(--border); border-radius: var(--radius); padding: 3rem 2rem; width: 100%; text-align: center; transition: all 0.3s ease; cursor: pointer; box-shadow: var(--shadow); }
        .drop-zone:hover, .drop-zone.drag-over { border-color: var(--primary); background-color: #eff6ff; transform: scale(1.005); }
        .icon { width: 64px; height: 64px; fill: var(--primary); margin-bottom: 1rem; opacity: 0.8; }
        
        .btn { padding: 0.75rem 1.5rem; border-radius: 9999px; font-weight: 600; border: none; cursor: pointer; font-size: 1rem; transition: all 0.2s; display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; }
        .btn-primary { background-color: var(--primary); color: white; }
        .btn-primary:hover { background-color: var(--primary-hover); transform: translateY(-1px); }
        .btn-dark { background-color: var(--text); color: white; }
        .btn-dark:hover { background-color: #000; transform: translateY(-1px); }
        .btn:disabled { opacity: 0.7; cursor: not-allowed; transform: none; }
        
        .btn-sm { padding: 0.4rem 0.8rem; font-size: 0.85rem; }
        .btn-secondary { background-color: white; color: var(--text); border: 1px solid var(--border); }
        .btn-secondary:hover { background-color: var(--bg); }
        
        input[type="file"] { display: none; }

        /* Workspace Area */
        #workspace { width: 100%; display: none; animation: slideUp 0.4s ease-out; }
        
        .toolbar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 1rem; }
        .file-count { font-weight: 700; color: var(--text); }

        /* Grid */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 1rem;
            margin-bottom: 6rem; /* Space for fixed footer */
        }

        .card {
            background: var(--surface);
            border-radius: 8px;
            border: 1px solid var(--border);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow);
            position: relative;
        }

        .card-img-wrapper {
            height: 120px;
            background: #f1f5f9;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-bottom: 1px solid var(--border);
        }
        .card-img-wrapper img { width: 100%; height: 100%; object-fit: cover; }

        .card-body { padding: 0.5rem; }
        .card-title { font-size: 0.75rem; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-light); margin-bottom: 0.5rem; }
        
        .btn-remove {
            position: absolute; top: 4px; right: 4px;
            width: 24px; height: 24px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 50%; background: rgba(0,0,0,0.5); color: white;
            border: none; cursor: pointer; font-size: 14px;
        }
        .btn-remove:hover { background: #ef4444; }

        /* Footer Action Bar */
        .action-bar {
            background: var(--surface);
            padding: 1rem;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            box-shadow: 0 -4px 20px rgba(0,0,0,0.1);
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 800px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .action-buttons { display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; }
        .action-buttons .btn { flex: 1; min-width: 200px; }

        .progress-bar { width: 100%; height: 4px; background: #e2e8f0; border-radius: 2px; overflow: hidden; display: none; }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; transition: width 0.2s; }

        footer { margin-top: auto; padding: 2rem; text-align: center; font-size: 0.8rem; color: var(--text-light); border-top: 1px solid var(--border); }

        @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

<header>
    <h1>FastPDF Converter</h1>
    <div class="tagline">Batch Process & Zip</div>
</header>

<main>
    <div class="drop-zone" id="dropZone">
        <svg class="icon" viewBox="0 0 24 24">
            <path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/>
        </svg>
        <h2>Drag & Drop Multiple Images</h2>
        <button class="btn btn-primary" style="margin-top:1rem" onclick="document.getElementById('fileInput').click()">Select Images</button>
        <input type="file" id="fileInput" multiple accept="image/jpeg, image/png, image/webp">
    </div>

    <div id="workspace">
        <div class="toolbar">
            <span class="file-count" id="fileCount">0 Images</span>
            <button class="btn btn-secondary btn-sm" onclick="clearAll()">Clear All</button>
        </div>

        <div class="grid-container" id="gridContainer"></div>

        <div class="action-bar">
            <div class="progress-bar" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>
            <div class="action-buttons">
                <button class="btn btn-dark" id="zipBtn">
                    <svg style="width:20px;height:20px;fill:currentColor" viewBox="0 0 24 24"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M16,11V13H13V15H16V17H13V19H11V11L16,11Z"/></svg>
                    Download All as ZIP
                </button>
                <button class="btn btn-primary" id="mergeBtn">
                    <svg style="width:20px;height:20px;fill:currentColor" viewBox="0 0 24 24"><path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z"/></svg>
                    Merge All into One PDF
                </button>
            </div>
        </div>
    </div>
</main>

<footer><p>&copy; 2024 FastPDF. No Server Uploads.</p></footer>

<script>
    // --- MAIN APP LOGIC ---
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const workspace = document.getElementById('workspace');
    const gridContainer = document.getElementById('gridContainer');
    const fileCount = document.getElementById('fileCount');
    const mergeBtn = document.getElementById('mergeBtn');
    const zipBtn = document.getElementById('zipBtn');
    const progressBar = document.getElementById('progressBar');
    const progressFill = document.getElementById('progressFill');

    let filesQueue = []; 

    // Event Listeners
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => {
        dropZone.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); });
    });
    dropZone.addEventListener('drop', (e) => handleFiles(e.dataTransfer.files));
    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
    
    // Paste Support
    document.addEventListener('paste', (e) => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        const files = [];
        for (let item of items) {
            if (item.kind === 'file' && item.type.startsWith('image/')) files.push(item.getAsFile());
        }
        if(files.length) handleFiles(files);
    });

    mergeBtn.addEventListener('click', processMerged);
    zipBtn.addEventListener('click', processZip);

    function handleFiles(fileList) {
        if (!fileList.length) return;
        workspace.style.display = 'block';
        dropZone.style.display = 'none';

        Array.from(fileList).forEach(file => {
            if (!file.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const item = {
                        id: Math.random().toString(36).substr(2, 9),
                        file: file,
                        dataUrl: e.target.result,
                        width: img.naturalWidth,
                        height: img.naturalHeight
                    };
                    filesQueue.push(item);
                    renderCard(item);
                    updateUI();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
        fileInput.value = '';
    }

    function renderCard(item) {
        const card = document.createElement('div');
        card.className = 'card';
        card.id = `card-${item.id}`;
        card.innerHTML = `
            <button class="btn-remove" onclick="removeFile('${item.id}')">&times;</button>
            <div class="card-img-wrapper"><img src="${item.dataUrl}"></div>
            <div class="card-body"><div class="card-title">${item.file.name}</div></div>
        `;
        gridContainer.appendChild(card);
    }

    window.removeFile = function(id) {
        filesQueue = filesQueue.filter(f => f.id !== id);
        document.getElementById(`card-${id}`).remove();
        updateUI();
        if(!filesQueue.length) { workspace.style.display = 'none'; dropZone.style.display = 'block'; }
    }

    window.clearAll = function() {
        filesQueue = [];
        gridContainer.innerHTML = '';
        workspace.style.display = 'none';
        dropZone.style.display = 'block';
    }

    function updateUI() {
        fileCount.textContent = `${filesQueue.length} Images`;
        mergeBtn.innerHTML = `Merge ${filesQueue.length} PDF${filesQueue.length>1?'s':''}`;
    }

    // --- ACTION: MERGE ALL ---
    function processMerged() {
        if (filesQueue.length === 0) return;
        startLoading(mergeBtn);
        setTimeout(() => {
            const pdfBlob = generatePDFBlob(filesQueue);
            downloadBlob(pdfBlob, "merged-document.pdf");
            stopLoading(mergeBtn, "Merge All into One PDF");
        }, 100);
    }

    // --- ACTION: BATCH ZIP ---
    async function processZip() {
        if (filesQueue.length === 0) return;
        startLoading(zipBtn);
        
        setTimeout(async () => {
            const zipWriter = new MiniZip();
            const nameTracker = {};

            filesQueue.forEach((item) => {
                // 1. Generate individual PDF for this image
                const pdfBlob = generatePDFBlob([item]);
                
                // 2. Determine cleaned filename (name without extension)
                let originalName = item.file.name.replace(/\.[^/.]+$/, "");
                let finalName = originalName;
                
                // 3. Handle duplicates
                if (nameTracker[originalName] !== undefined) {
                    nameTracker[originalName]++;
                    finalName = `${originalName} (${nameTracker[originalName]})`;
                } else {
                    nameTracker[originalName] = 0;
                }

                // 4. Add to ZIP using the final PDF name
                zipWriter.add(`${finalName}.pdf`, pdfBlob);
            });

            // 5. Download
            const zipBlob = await zipWriter.generate();
            downloadBlob(zipBlob, "converted-pdfs.zip");
            stopLoading(zipBtn, "Download All as ZIP");
        }, 100);
    }

    function startLoading(btn) {
        progressBar.style.display = 'block';
        progressFill.style.width = '50%';
        btn.disabled = true;
        btn.dataset.originalText = btn.innerHTML;
        btn.innerHTML = "Processing...";
    }

    function stopLoading(btn, resetText) {
        progressFill.style.width = '100%';
        setTimeout(() => {
            progressBar.style.display = 'none';
            progressFill.style.width = '0';
            btn.disabled = false;
            btn.innerHTML = resetText;
        }, 500);
    }

    function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }


    // --- ENGINES ---

    /**
     * PDF ENGINE (Binary Construction)
     * Creates a PDF from an array of Image Objects
     */
    function generatePDFBlob(images) {
        const parts = [];
        let offset = 0;
        const xref = [];
        
        function add(str) {
            if(typeof str === 'string') { parts.push(str); offset += str.length; } 
            else { parts.push(str); offset += str.byteLength; }
        }
        function addXref() { xref.push(("0000000000" + offset).slice(-10) + " 00000 n \n"); }

        add("%PDF-1.4\n");
        xref.push("0000000000 65535 f \n"); // 0

        const count = images.length;
        const pageIds = [];
        for(let i=0; i<count; i++) pageIds.push(`${3 + i*3} 0 R`);

        // 1. Catalog
        addXref(); add(`1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n`);
        // 2. Page Tree
        addXref(); add(`2 0 obj\n<< /Type /Pages /Kids [${pageIds.join(' ')}] /Count ${count} >>\nendobj\n`);

        images.forEach((img, i) => {
            const pageId = 3 + i*3;
            const contentId = 4 + i*3;
            const imgId = 5 + i*3;
            const w = Math.floor(img.width * 0.75);
            const h = Math.floor(img.height * 0.75);

            // 3. Page
            addXref(); add(`${pageId} 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${w} ${h}] /Resources << /XObject << /I${i} ${imgId} 0 R >> >> /Contents ${contentId} 0 R >>\nendobj\n`);
            // 4. Content
            addXref(); 
            const stream = `q\n${w} 0 0 ${h} 0 0 cm\n/I${i} Do\nQ`;
            add(`${contentId} 0 obj\n<< /Length ${stream.length} >>\nstream\n${stream}\nendstream\nendobj\n`);
            // 5. Image
            addXref();
            const bin = base64ToUint8Array(img.dataUrl.split(',')[1]);
            add(`${imgId} 0 obj\n<< /Type /XObject /Subtype /Image /Width ${img.width} /Height ${img.height} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${bin.byteLength} >>\nstream\n`);
            add(bin);
            add(`\nendstream\nendobj\n`);
        });

        const xrefOffset = offset;
        add("xref\n"); add(`0 ${xref.length}\n`);
        xref.forEach(x => add(x));
        add(`trailer\n<< /Size ${xref.length} /Root 1 0 R >>\nstartxref\n${xrefOffset}\n%%EOF`);
        return new Blob(parts, { type: 'application/pdf' });
    }

    /**
     * MINI ZIP ENGINE (Vanilla JS, No Dependencies)
     * Creates an uncompressed (Store) ZIP file.
     */
    class MiniZip {
        constructor() {
            this.files = [];
        }

        async add(filename, contentBlob) {
            const buffer = await contentBlob.arrayBuffer();
            this.files.push({ name: filename, data: new Uint8Array(buffer) });
        }

        async generate() {
            const parts = [];
            let offset = 0;
            const centralDir = [];

            // Helpers
            const enc = new TextEncoder();
            const crcTable = this.makeCrcTable();
            
            const write4 = (view, off, val) => view.setUint32(off, val, true);
            const write2 = (view, off, val) => view.setUint16(off, val, true);

            for(const file of this.files) {
                const nameBytes = enc.encode(file.name);
                const data = file.data;
                const crc = this.crc32(data, crcTable);
                const size = data.length;

                // Local Header (30 bytes + name)
                const header = new Uint8Array(30 + nameBytes.length);
                const view = new DataView(header.buffer);

                write4(view, 0, 0x04034b50); // Signature
                write2(view, 4, 10); // Version
                write2(view, 6, 0);  // Flags
                write2(view, 8, 0);  // Compression (0 = Store)
                write2(view, 10, 0); // Time (placeholder)
                write2(view, 12, 0); // Date (placeholder)
                write4(view, 14, crc);
                write4(view, 18, size); // Compressed Size
                write4(view, 22, size); // Uncompressed
                write2(view, 26, nameBytes.length);
                write2(view, 28, 0); // Extra len
                header.set(nameBytes, 30);

                parts.push(header);
                parts.push(data);

                // Central Directory Record for later
                centralDir.push({ 
                    nameBytes, size, crc, offset 
                });

                offset += header.length + data.length;
            }

            const centralStart = offset;

            // Write Central Directory
            for (const r of centralDir) {
                const row = new Uint8Array(46 + r.nameBytes.length);
                const view = new DataView(row.buffer);
                
                write4(view, 0, 0x02014b50); // Signature
                write2(view, 4, 10); // Version made by
                write2(view, 6, 10); // Version needed
                write2(view, 8, 0);  // Flags
                write2(view, 10, 0); // Compression
                write4(view, 16, r.crc);
                write4(view, 20, r.size);
                write4(view, 24, r.size);
                write2(view, 28, r.nameBytes.length);
                write4(view, 42, r.offset);
                row.set(r.nameBytes, 46);

                parts.push(row);
                offset += row.length;
            }

            // End of Central Directory (22 bytes)
            const eocd = new Uint8Array(22);
            const view = new DataView(eocd.buffer);
            write4(view, 0, 0x06054b50);
            write2(view, 8, this.files.length); // Count disk
            write2(view, 10, this.files.length); // Count total
            write4(view, 12, offset - centralStart); // Size of CD
            write4(view, 16, centralStart); // Offset of CD

            parts.push(eocd);

            return new Blob(parts, { type: 'application/zip' });
        }

        // Standard CRC32 Implementation
        makeCrcTable() {
            let c;
            const table = [];
            for(let n =0; n < 256; n++){
                c = n;
                for(let k =0; k < 8; k++){
                    c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
                }
                table[n] = c;
            }
            return table;
        }

        crc32(uint8array, table) {
            let crc = 0 ^ (-1);
            for (let i = 0; i < uint8array.length; i++) {
                crc = (crc >>> 8) ^ table[(crc ^ uint8array[i]) & 0xFF];
            }
            return (crc ^ (-1)) >>> 0;
        }
    }

    function base64ToUint8Array(base64) {
        const binStr = atob(base64);
        const len = binStr.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binStr.charCodeAt(i);
        return bytes;
    }
</script>
</body>
</html>
